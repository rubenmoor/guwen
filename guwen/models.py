from __future__ import unicode_literals

from django.db import models
from django.db.models import Q
from django.contrib.auth.models import User

from django.utils.safestring import mark_safe

class Hanzi(models.Model):
    """ a chinese character or a primitive used as component in a character """
    date_created = models.DateTimeField(auto_now_add=True)
    # heisigFrame multiplied with 10 to allow for primitives
    # (w/o heisigFrame) to fit in between in order
    heisigID = models.PositiveIntegerField(default=0)
    # text representation
    char = models.CharField(max_length=1, blank=True)
    isHeisigPrimitive = models.BooleanField(default=False)
    isRealPrimitive = models.BooleanField(default=False)
    numStrokes = models.PositiveSmallIntegerField(blank=True, default=0)
    heisigBook = models.CharField(max_length=16, default='RSH1')
    heisigLesson = models.PositiveSmallIntegerField(blank=True, default=0)
    heisigFrame = models.PositiveSmallIntegerField(blank=True, default=0)
    dataExceptionInfo = models.PositiveSmallIntegerField(blank=True, default=0)
    isDataComplete = models.BooleanField(default=False)
    isDataLocked = models.BooleanField(default=False)

    def getKeywordPrimitiveMeanings(self):
        keywordPrimitiveMeanings = []
        if self.termKeyword.hanziPrimitive_id is None:
            keywordPrimitiveMeanings.append(self.termKeyword)
        keywordPrimitiveMeanings += list(self.termPrimitiveMeanings.all())
        return keywordPrimitiveMeanings

    def getPinyinString(self):
        return ", ".join([syllable.pinyin for syllable in self.syllables.all()])

    def __unicode__(self):
        return self.char

    def setSelTermPrimitiveMeaning(self, term):
        self.selTermPrimitiveMeaning = term

    def getSelTermPrimitiveMeaning(self):
        return self.selTermPrimitiveMeaning

    def getOtherTermPrimitiveMeanings(self):
        return [t.term for t in self.termPrimitiveMeanings.all() if t.term != self.selTermPrimitiveMeaning]
        
    def getDataExceptionInfo(self):
        return {
            self.OK: 'OK',
            self.PANGOLIN: 'pangolin',
            self.NO_SYMBOL: 'no symbol',
            }[self.dataExceptionInfo]

    def getPrimitiveMeaningsString(self):
        return ', '.join([t.term for t in self.termPrimitiveMeanings.all()])

    def getElementsString(self):
        return ', '.join([t.term for t in self.termElements.all()])

    OK = 0
    PANGOLIN = 1
    NO_SYMBOL = 2
    
class EnglishTerm(models.Model):
    term = models.CharField(max_length=72)
    # the one character that has this term as keyword, if it is used as keyword at all
    hanziCharacter = models.OneToOneField('Hanzi', related_name='termKeyword', blank=True, null=True)
    # the one hanzi (character or primitive) that has this term as one of its primitive meanings
    hanziPrimitive = models.ForeignKey('Hanzi', related_name='termPrimitiveMeanings', blank=True, null=True)
    # any hanzi that uses this term as element (e.g. in the Heisig story)
    hanziUsers = models.ManyToManyField('Hanzi', related_name='termElements', db_table='guwen_ptrelementuser', blank=True)
    #hanziUsers = models.ManyToManyField('Hanzi', related_name='termElements', through='PtrElementUser')

    def getHanziPrimitive(self):
        # if no primitive meaning is specified, the keyword takes this function
        # ..._id is automatically generated by models.ForeignKey('...')
        if self.hanziPrimitive_id is None:
            return self.hanziCharacter
        # Heisig sometimes uses primitive meanings that are already the
        # keyword for an unrelated character, in case of ambiguity get
        # the character behind the *primitive meaning*
        else:
            return self.hanziPrimitive

    def __unicode__(self):
        return self.term

class HanziMeta(models.Model):
    numHanzi = models.IntegerField()
    maxHeisigID = models.IntegerField()
    percentageDataComplete = models.DecimalField(max_digits=4, decimal_places=1)
    percentageDataLocked = models.DecimalField(max_digits=4, decimal_places=1)
    dateUpdated = models.DateTimeField(auto_now=True)

    @classmethod
    def update(cls):
        meta = HanziMeta.objects.latest()
        meta.numHanzi = Hanzi.objects.filter(isRealPrimitive=False).count()
        meta.maxHeisigID = Hanzi.objects.all().order_by('-heisigID')[0].heisigID
        meta.percentageDataComplete = Hanzi.objects.filter(isDataComplete=True).count() / Hanzi.objects.count()
        meta.percentageDataLocked = Hanzi.objects.filter(isDataLocked=True).count() / Hanzi.objects.count()
        meta.save()

    class Meta:
        get_latest_by = 'dateUpdated'

class Syllable(models.Model):
    """ a mandarin syllable, based on the pronouncation """
    pinyin_latin = models.CharField(max_length=8, unique=True)
    pinyin = models.CharField(max_length=8)
    pinyinWOTone = models.CharField(max_length=7)
    tone = models.PositiveSmallIntegerField()
    hanzis = models.ManyToManyField('Hanzi', related_name='syllables', through='PtrHanziSyllable')

    # tones
    FIRST = 0
    SECOND = 1
    THIRD = 2
    FORTH = 3

    def __unicode__(self):
        return self.pinyin

    @classmethod
    def convertLatinToUnicode(cls, latin_pinyin):
        from cjklib.reading import ReadingFactory
        f = ReadingFactory()
        return f.convert(latin_pinyin, 'Pinyin', 'Pinyin', sourceOptions={
            'toneMarkType': 'numbers',
            'yVowel': 'v',
            'missingToneMark': 'fifth'
            })
    
    @classmethod
    def getPinyinLatin(cls, pinyin):
        import cjklib
        from cjklib.reading import operator, converter
        targetOp = operator.PinyinOperator(toneMarkType='numbers')
        pinyinConv = converter.PinyinDialectConverter(targetOperators=[targetOp])
        latin_string = pinyinConv.convert(pinyin, 'Pinyin', 'Pinyin')
        if not latin_string:
            return 'err0'
        return latin_string

class PtrHanziSyllable(models.Model):
    """ nothing unambigious in mandarin """
    hanzi = models.ForeignKey('Hanzi', related_name='ptrSyllableLexicalEntry')
    syllable = models.ForeignKey('Syllable', related_name='ptrHanziLexicalEntry')
    lexical_entry = models.ForeignKey('LexicalEntry', related_name='ptrHanziSyllable', null=True, blank=True)

class LexicalEntry(models.Model):
    """ description of the meanings of a character
        ideally linked to instances of PtrHanziSyllable, because every character
        syllable pair has a distinct meaning, otherwise just linked to Character """
    description = models.TextField()
    hanzi = models.ForeignKey('hanzi', related_name='lexical_entries')

    @classmethod
    def update_hanzi(cls, hanzi):
        data_objects = CedictDataSingle.objects.filter(simplified_hanzi=hanzi.char)
        for data in data_objects:
            pinyin = Syllable.convertLatinToUnicode(data.latin_pinyin.lower())
            description = data.description.replace('/', '; ')
            lexicalEntry, created = LexicalEntry.objects.get_or_create(
                description=description,
                defaults={'hanzi': hanzi},
                )
            syllable, created = Syllable.objects.get_or_create(
                pinyin_latin=data.latin_pinyin.lower(),
                defaults={
                    'pinyin': pinyin,
                    'pinyinWOTone': data.latin_pinyin[:-1].lower(),
                    'tone': data.latin_pinyin[-1],
                    }
                )
            ptr, created = PtrHanziSyllable.objects.get_or_create(
                hanzi=hanzi,
                syllable=syllable,
                defaults={'lexical_entry': lexicalEntry}
                )

    @classmethod
    def update_all(cls):
        Syllable.objects.all().delete()
        # limitation of sqlite3
        while LexicalEntry.objects.count():
            LexicalEntry.objects.all()[0].delete()
        PtrHanziSyllable.objects.all().delete()
        hanzis = Hanzi.objects.all()
        for hanzi in hanzis:
            LexicalEntry.update_hanzi(hanzi)

    @classmethod
    def convert_pinyin_all(cls):
        for lexicalEntry in cls.objects.all():
             lexicalEntry.convert_pinyin()
             lexicalEntry.save()
            
    def convert_pinyin(self):
        import re
        def replace_brackets(matchobj):
            pinyin_str = []
            for group in matchobj.groups():
                pinyin_str.append(Syllable.convertLatinToUnicode(group.strip()))
            return '[{}]'.format(' '.join(pinyin_str))
        self.description = re.sub('\[(\w+\s?)+\]', replace_brackets, self.description)
        
    def __unicode__(self):
        return mark_safe(self.description.replace('[', '<strong>').replace(']', '</strong>'))

class CedictDataSingle(models.Model):
    simplified_hanzi = models.CharField(max_length=1)
    traditional_hanzi = models.CharField(max_length=1)
    latin_pinyin = models.CharField(max_length=72)
    description = models.TextField()

    @classmethod
    def update(cls, cedict_file):
        import gzip
        import re
        CedictDataSingle.objects.all().delete()
        pattern = re.compile(r'(\S)\s+(\S)\s+\[(\w+)\]\s+/(.*)/')
        with gzip.open(cedict_file.temporary_file_path(), 'r') as lines:
            for line in lines:
                match = re.match(pattern, line.decode('utf-8'))
                if match is not None:
                    groups = match.groups()
                    data_single = CedictDataSingle(
                        traditional_hanzi=groups[0],
                        simplified_hanzi=groups[1],
                        latin_pinyin=groups[2],
                        description=groups[3],
                        )
                    data_single.save()

    def __unicode__(self):
        return '{} [{}] {} {}'.format(
            self.simplified_hanzi,
            self.traditional_hanzi,
            self.latin_pinyin,
            self.description,
            )

class HeisigExcelPinyin(models.Model):
    heisigID = models.IntegerField()
    pinyin = models.CharField(max_length=72)

    @classmethod
    def update(cls):
        for hep in cls.objects.all():
            hanzi = Hanzi.objects.get(heisigID=hep.heisigID)
            new_pinyins = hep.pinyin.replace('{', '').replace('}', '')
            if new_pinyins:
                for new_pinyin in new_pinyins.split(','):
                    pinyin_latin = Syllable.getPinyinLatin(new_pinyin)
                    syllable, created = Syllable.objects.get_or_create(pinyin_latin=pinyin_latin, defaults={
                        'pinyin': new_pinyin,
                        'pinyinWOTone': pinyin_latin[:-1],
                        'tone': pinyin_latin[-1],
                        })
                    ptrHanziSyllable, created = PtrHanziSyllable.objects.get_or_create(hanzi=hanzi, syllable=syllable)

